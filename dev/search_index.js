var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Lazy2","category":"page"},{"location":"#Lazy2","page":"Home","title":"Lazy2","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Lazy2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Lazy2]","category":"page"},{"location":"#Lazy2.takeuntil-Tuple{Function, List}","page":"Home","title":"Lazy2.takeuntil","text":"takeuntil(pred, list)\n\nTake the elements in list until the pred function return true. Notice that the one which makes pred true is also taken. All elements will be taken if no one satisfy the pred function.\n\n\n\n\n\n","category":"method"},{"location":"#Lazy2.tupleassign-Tuple{Any, Any}","page":"Home","title":"Lazy2.tupleassign","text":"Generate an expression like (a, b) = (c, d).\n\n\n\n\n\n","category":"method"},{"location":"#Lazy2.@>-Tuple","page":"Home","title":"Lazy2.@>","text":"The threading macro is like a more flexible version of the |> operator.\n\n@> x f = f(x)\n@> x g f == f(g(x))\n@> x a b c d e == e(d(c(b(a(x)))))\n\nUnlike |>, functions can have arguments - the value preceding a function will be treated as its first argument\n\n@> x g(y, z) f == f(g(x, y, z))\n\n@> x g f(y, z) == f(g(x), y, z)\n\nSee also @>>, @as.\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@>>-Tuple","page":"Home","title":"Lazy2.@>>","text":"Same as @>, but threads the last argument.\n\n@>> x g(y, z) f == f(g(y, z, x))\n\n@>> x g f(y, z) == f(y, z, g(x))\n\nSee also: @>>\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@as-Tuple{Any, Vararg{Any}}","page":"Home","title":"Lazy2.@as","text":"@as as, exs...\n\n@as lets you name the threaded argmument\n\n@as _ x f(_, y) g(z, _) == g(z, f(x, y))\n\nAll threading macros work over begin blocks\n\n6 === @as x 2 begin\n  x^2\n  x+2\nend\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@bounce-Tuple{Any}","page":"Home","title":"Lazy2.@bounce","text":"Tail recursion that doesn't blow the stack.\n\n@bounce even(n) = n == 0 ? true : odd(n-1)\n@bounce odd(n) = n == 0 ? false : even(n-1)\n\neven(1_000_000) # Blows up without `@bounce`.\n#> true\n\nFor simple cases you probably want the much faster @rec.\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@d-Tuple","page":"Home","title":"Lazy2.@d","text":"Creates an untyped dictionary, e.g.\n\njulia> @d(:a=>1, :b=>2)\nDict{Any,Any} with 2 entries:\n :a => 1\n :b => 2\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@defonce-Tuple{Any}","page":"Home","title":"Lazy2.@defonce","text":"Stop Julia from complaining about redifined struct/consts –\n\n@defonce struct MyType\n  ...\nend\n\nor\n\n@defonce const pi = 3.14\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@dotimes-Tuple{Any, Any}","page":"Home","title":"Lazy2.@dotimes","text":"@dottimes(n, body)\n\nRepeat body n times.\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@forward-Tuple{Any, Any}","page":"Home","title":"Lazy2.@forward","text":"@forward T.x functions...\n\nDefine methods for functions on type T, which call the relevant function on the field x.\n\nExample\n\nstruct Wrapper\n    x\nend\n\n@forward Wrapper.x  Base.sqrt                                  # now sqrt(Wrapper(4.0)) == 2.0\n@forward Wrapper.x  Base.length, Base.getindex, Base.iterate   # several forwarded functions are put in a tuple\n@forward Wrapper.x (Base.length, Base.getindex, Base.iterate)  # equivalent to above\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@oncethen-Tuple{Expr}","page":"Home","title":"Lazy2.@oncethen","text":"A do-while loop – executes the while loop once regardless of the condition, then tests the condition before subsequent iterations.\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@rec-Tuple{Any}","page":"Home","title":"Lazy2.@rec","text":"Enables efficient recursive functions, e.g.\n\n@rec reduce(f::Function, v, xs::List) =\n  isempty(xs) ? v : reduce(f, f(v, first(xs)), tail(xs))\n\nWithout @rec this function would overflow the stack for lists of 80,000 or more elements.\n\nCaveats:\n\nNo support for trampolining, i.e. only calls to the   given function are optimised away.\nIgnores multiple dispatch – it is assumed that the function's   name always refers to the given definition.\nDon't rebind the function's name in a let (see above).\nDon't use this with varargs functions.\n\nUse the more flexible, but slower, @bounce to avoid these issues.\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@switch-Tuple","page":"Home","title":"Lazy2.@switch","text":"A switch statement of sorts:\n\n@switch x begin\n  1; \"x equals one!\"\n  2; \"x equals two!\"\n  \"x equals something else!\"\nend\n\nHowever, it's a bit more general than a regular switch in that you can test more than just equality:\n\n@switch isa(x, _) begin\n  Integer; \"x is an integer!\"\n  FloatingPoint; \"x is a float!\"\n  \"x is something else!\"\nend\n\n@switch _ begin\n  a > b;  \"more than!\"\n  a < b;  \"less than!\"\n  a == b; \"equal!\"       # Note that this level of enthusiasm is not mandatory.\nend\n\nWhere _ is replaced by the value for testing in each case. The final expression, if there is one, is used as the default value; if there is no default and nothing matches an error will be thrown.\n\n\n\n\n\n","category":"macro"},{"location":"#Lazy2.@with-Tuple{Any}","page":"Home","title":"Lazy2.@with","text":"End-less let block, e.g.\n\n@with (x = 1, y = 2),\n  x+y\n\n\n\n\n\n","category":"macro"}]
}
